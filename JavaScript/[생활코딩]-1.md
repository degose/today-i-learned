[생활코딩] 1 - 객체지향 프로그래밍
========


## << 객체 지향 프로그래밍(Object-Oriented Programming) >>
- 로직을 상태(state)와 행위(behave)로 이루어진 객체로 만드는 것
- 객체는 변수와 메소드를 그룹핑한 것이다.

## << 생성자와 new >>
- `객체` : 서로 연관된 변수와 함수를 그룹핑한 것. 객체 내 변수를 property 함수를 method라고 한다.
```js
var person = {} // object
person.name = 'gose';
person.introduce = function(){
    return 'My name is ' + this.name;
}
document.write(person.introduce());
// My name is gose
```
- 객체를 만드는 또다른 방법 property와 method를 직접 정의해 주는것.
```js
var person = {
    'name' : 'egoing',
    'introduce' : function(){
        return 'My name is ' + this.name;
    }
};
```

- `생성자(constructor)`: 객체를 만드는 역할을 하는 함수. 자바스크립트에서 함수는 재사용 가능한 로직의 묶음이 아니라 객체를 만드는 창조자라 할 수 있다.
- 함수를 호출할 때 new를 붙이면 새로운 객체를 만든 후에 이를 리턴한다.
```js
function Person(){}
var p0 = Person(); //p0을 호출하면 undefined로 나온다.
var p = new Person(); // p를 호출하면 Person{}로 나온다.(비어있는 객체)
p.name = 'gose';
p.introduce = function(){
    return 'My name is ' + this.name;
}
console.log(p.introduce());
```
- 생성자를 활용해 개선된 코드
- 생성자 내에서 이 객체의 프로퍼티를 정의하고 있다. 객체에 대한 `초기화`
- 생성자 함수는 일반함수와 구분짓기 위해 첫글자를 대문자로 표기한다.
```js
function Person(name){
    this.name = name;
    this.introduce = function(){
      return 'My name is ' + this.name;  
    }
}
var p1 = new Person('gose');
document.write(p1.introduce());
var p2 = new Person('maso');
document.write(p2.introduce());
```


## << 전역객체 >>
- Global object. 모든객체는 이 전역객체의 프로퍼티다.
- 객체를 명시하지 않으면 암시적으로 window의 프로퍼티로 간주된다.
- 자바스크립트에서 모든 객체는 기본적으로 전역객체의 프로퍼티
- 웹브라우저에서 전역객체는 window지만 node.js에서는 global이다.
```js
function func(){
    alert('Hello');
}
func();//함수
window.func();//'윈도우'라는 전역객체의 메서드
```
```js
var o = {'func' : function()}{
    alert('Hello');
}
o.func();
window.o.func();
```


## << this >>
- this는 함수 내에서 함수 호출 맥락(context)를 의미 / 함수와 객체의 관계가 느슨한 자바스크립트에서 this는 이 둘을 연결시켜주는 역할을 한다. 함수 내에 약속되어 있는 변수
- [함수 호출]
    - 아무것도 속해있지 않은 function 안에 this 는 window를 가리킨다. 왜냐하면 func()이라는 메서드는 실제로는 window라고 하는 객체의 매서드이기 때문에
```js
function func(){
    if(window === this){
        console.log('window === this');
    }
}
func();
```
- [메소드의 호출]
    - 객체의 소속인 메소드의 this는 그 객체를 가르킨다.
```js
var o = {
    func : function(){
        if(o === this){
            console.log('window === this');
        }
    }
}
o.func();
```

- [생성자의 호출]
    - 생성자는 빈 객체를 만든다. 이 객체 내에서 this는 만들어진 객체를 가리킨다.
    - 생성자가 실행되기 전까지는 객체는 변수에도 할당될 수 없기 때문에 this가 아니면 객체에 대한 어떠한 작업을 할 수 없다. 필수다.
```js
var funcThis = null; 
 
function Func(){
    funcThis = this; // var가 없기 때문에 window를 가리킨다.
}
var o1 = Func();
if(funcThis === window){
    document.write('window <br />'); // window
}
 
var o2 = new Func();
if(funcThis === o2){
    document.write('o2 <br />'); // o2
}

function Func(){
    document.write(o);
}
var o = new Func(); // undefined
```


## << apply, call >>
- 함수 리터럴 / 함수도 객체이다.
```js
function sum(x,y){return x+y}
sum(1,2) //3
var sum2 = new Function('x','y','return x+y');
sum2(1,2);//3
```

- 함수의 메소드인 apply,call을 이용하면 this의 값을 제어할 수 있다.
- *switch문은 if문과 대체제,(for문과while문이 대체제인것 처럼)
- 객체(master) / 메소드(slave노예)
```js
var o = {}
var p = {}
function func(){
    switch(this){
        case o:
            document.write('o<br />');
            break;
        case p:
            document.write('p<br />'); 
            break;
        case window:
            document.write('window<br />');
            break;          
    }
}
func(); //window
func.apply(o); // o
func.apply(p); // p
```