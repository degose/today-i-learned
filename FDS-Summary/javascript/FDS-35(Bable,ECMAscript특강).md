FDS-35-Babel + ECMA script 2015 특강
========

## 이웅모님 (http://poiemaweb.com 운영자)

## 1. let, const와 블록 레벨 스코프
- <http://poiemaweb.com/es6-block-scope>
### var 키워드
### 설계상의 오류
- input요소 안에 값이 들어왔을 때 몇글자인지, 무엇인지에 대해서만 확인하는 용이었는데 -> 프론트엔드가 비대해지면서 이제는 큰 어플리케이션도 자바스크립트로 만들 필요가 생겼다.
- 주로 웹페이지를 쓰는 회사에 간다면 prototype을 쓸 일이 별로 없다.(대규모 프로젝트에서 사용)
- 좋게 얘기하면 유연하고, 나쁘게 얘기하면 흐리멍텅하다.
- 블록레벨단위의 스코프를 갖지 않는다. 함수에서만 스코프를 갖고 그 이외에는 다 전역
- 전역변수는 안쓰는게 좋다. 그러나 es5에서는 안쓰기가 어렵다. -> 모듈스코프로 억지로 만들어서 사용
- 변수 호이스팅 : 할당문이 나오기 전까지 undefined  / 함수 호이스팅 

### let
#### block-level-scope를 지원한다.
- 스코프체인은 모든 언어에 해당
- 코드블럭 {} 
- var 키워드
- 1.변수 선언 (context에 이런 게 있다 말한다.) -> 2.초기화 (메모리에 변수가 있는 영역 만들기) -> 3.할당 (메모리에 할당)
- 예전에는 똑같은 이름의 변수를 두번쓰면 같은 변수에 값을 재설정하고 에러를 안띄웠는데, let을 쓰면 에러를 발생시킨다(문법오류, 같은 이름의 변수가 있어서)
#### 호이스팅
- let은 호이스팅을 한다. 그러나 다르게 움직인다.
- 호이스팅은 하지만 참조를 안하는 것.
#### 클로저
- 함수에서 외부함수에 있는 변수를 내부함수가 참조할 수 있는데, 외부함수의 라이프 사이클이 소멸된 후에도 참조할 수 있는것. 함수가 소멸된 이후에도 살아남은 변수 -> 자유변수 -> 자유변수에 대하여 닫혀있다. -> 클로저
- function foo(x) {} -> 여기서 x는 지역변수(매개변수는 함수 내에서 지역변수처럼 사용된다.)
- 클로저를 만들고 싶을때 : 무조건 살려야한다고 생각한 함수를 싼다.(스코프를 만들려고) 매개변수로 i를 전달해서
- let을 쓰는 순간 그냥 쓰면 된다. for문 자체가 스코프, i 자체가 지역변수이면서 자유변수가 된다. for문이 실행 컨텍스트가 종료 되더라도 i가 살아있다.

#### 전역객체와 let

### const
- 기본적으로 상수를 위한것. 상수는 바뀌면 안되는 것
#### 선언과 초기화
- 선언과 동시에 초기화,할당
#### 객체
- 문자,숫자,불린,언디파인드,널 빼고 다 객체 ->값자체를 갖고 있다. 변경할 수 없다.(복사)
- 객체 콜바이 레퍼런스 콜바이 
- 객체는 참조
- 레퍼런스를 가지고 있기 때문에 
- 재할당이 안된다.
- 주소값은 건들지 않고 안에 프로퍼티는 수정이 된다.
- 큰 프로젝트 작업 시 객체를 바꾸지 못하게 얼려야 한다.  쓰고 싶다면 copy를 해서 변경해서 쓰고 버려야한다.
- 재할당은 안되지만 객체의 내용은 바꿀 수 없다.

#### 약속
- var사용하지 않는다.
- 재할당이 필요한 5개는 let을 쓰고 그 이외에는 다 const를 쓴다. -> 객체는 프로퍼티 변경이 가능하기 때문이다.





## 2. 템플릿 리터럴(Template Literals)
- <http://poiemaweb.com/es6-template-literals>
### 템플릿
- 미리 형태를 만들어놓고 변수처럼 사용하는 것
- '',"" 따옴표, 등등 쓸 때 이스케이프시퀀스(백슬래시\) 사용해야함
- ``이 것을 쓴다. -> 이 안에서는 자유롭게 쓸 수 있다.
- ${}이 표현식을 쓰면 문자열로 자동 변환 -> 스트링 인터폴레이션
- 표현식 -> 하나의 값으로 수렴될 수 있다. -> 그 값이 문자열로 형변환 될 수 있다.



## 3. 화살표 함수(Arrow function)
- <http://poiemaweb.com/es6-arrow-function>
- 링팅?? es린트??
- function이라는 단어를 안쓰고 매개변수와 함수의 {}를 화살표(=>)로 연결해주는것
- 콜백에 적합
### 호출
- function이라는 단어를 생략해야되기 때문에 선언으로만 할 수 밖에 없다.
### 주의사항
- 아규먼트 객체 -> 함수 내부에서만 참조할 수 있다. 함수만의 객체 -> 인자의 리스트를 갖고있다. => 유사배열 (노드리스트, html 콜렉션) => 순회가 가능하다
- for in 문으로 할 수 있었다. 하지만 -> 브레이크안되고, 순서, ...
- 인자의 개수가 정해지지 않은 함수를 만들 때 => 가변인자함수
- reduce, map, 등등의 함수를 잘 써야한다.(배열을 잘 써야한다.) -> 새로운 함수들을 공부해야한다.
### rest 파라미터
- 아규먼트의 문제는 배열이 아니다. 그래서 배열로 바꿔줘야했다. -> 그런데 es6에서는 배열로 쓸 수 있다.

### this
- 콜백함수 내에서 this는 무조건 전역
- es5에서는 함수 내에 this는 전역객체(window)를 가리킨다.
- 단 함수를 매서드로 쓸 때, 생성자 함수로 쓸 때만 this가 틀리다.
- 생성자함수 -> instance / 메서드 -> 메서드를 호출 할 객체
- arrow함수에서 this는 우리가 원하던 그 값을 가르킨다. 

- 생성자함수 -> 인스턴스를 생성하려고 있는 함수. 모든 함수는 프로토타입이라는 프로퍼티를 갖는다. 객체는 프로토타입이라는 프로퍼티가 없다. 함수 객체만 있따.
- foo.porototype 
- 인스턴스의 부모를 가리키는 `__proto__` function.prototype / Object.prototype
- 생성자 함수, 프로토타입에 대한 이해
- var pre = new Prefixer('Hi'); -> 여기서 new를 왜 써주는 것일까? 함수지향 자바스크립트를 객체지향처럼 보이기 위한 것 아닐까?
- new를 쓸 때와 안쓸 때의 결과값이 다를텐데, new는 도대체 어떤 역할을 하는것일까?
- 인스턴스와 객체
- 클래스가 만드는 객체 : 인스턴스

- es6에서는 
1. this를 일단 저장해놓는다. -> that으로.
2. array에 map함수는 (콜백함수, this)를 인자로 받는다.
3. bind를 쓰는 방법 -> 명시적으로 this를 주는 것
- 렉시컬 디스
- 주의점
  - 메서드에 쓰면 안된다.
  - prototype
  - 생성자 함수에 쓰면 안된다.



## 4. 기본 파라미터 초기값, Rest 파라미터, Spread 연산자
- <http://poiemaweb.com/es6-extended-parameter-handling>
### 기본 파라미터 초기값
- Typescript 
  - int A
- 옛날의 함수는 변수에 type 구분 없이 할당이 가능했다.
- 그런데 대규모 프로젝트에서는 굉장히 불편
- type이 무엇인지, 인자가 있는지 없는지 테스팅하고 넘기는 과정이 필요.

### rest 파라미터
- 매개변수에 스프레드 연산자를 써서 인자로 전달을 하면 배열로 전달이 된다.
- 맨 뒤에만 와야한다.
- 나머지를 다 끌어모아서 배열로 쓴다.
### spread 연산자
- 굉장히 많이 쓴다.
- 피는 것 펼치는 것
- (...)
- es5에서는 apply에 인자의 리스트로 넘겨줬어야 하는데
- spread 연산자를 사용하면 알아서 풀어져서 들어간다.
- spread로 할 수 있는 것 -> concat, push, apply, splice
- slice()를 하면 값이 똑같은 다른 배열을 가르킨다.(카피를 한다.)




## 5. 디스트럭처링(Destructuring)
- <http://poiemaweb.com/es6-destructuring>
- 구조를 허무는 것
- 객체와 배열에서만 쓴다.
- 요소들을 끄집어 내서 내가 원하는 변수에 넣어준다.
- 데이터 자료 구조를 부셔서 변수에 할당해준다.
### 객체 디스트럭처링
- 굉장히 유용
- 프로퍼티 키를 기준으로 가져온다.





## 6. 객체 리터럴 프로퍼티 기능 확장
- <http://poiemaweb.com/es6-enhanced-object-property>
### `__proto__`프로퍼티에 의한 상속
- es5에서 상속을 구현하려는 여러가지 방법 중 하나
- object라는 객체의 메서드를 가져다 쓰는것.
- 프로토타입 패턴 상속
- `__proto__`를 key값으로 하고 활용 가능


## 7. 클래스(Class)
- <http://poiemaweb.com/es6-class>
- 자바스크립트는 포로토타입 기반 객체지향형 언어(논쟁중)
- 신텍틱 슈가(문법적 설탕) -> 기존에 있는 문법을 좀 더 사용하기 쉽게 랩핑해 놓은 것.
- 프로토타입을 사용하여
- 함수객체는 호출 가능 / 일반 객체는 호출 안돼
- 함수객체는 prototype은 생성자함수의 prototype을 가리킨다.
- 일반데이터(멤버변수) - 데이터를 갖고있는  프로퍼티 / 메서드
- 메서드들이 데이터를 가지고 조작하는 것

- 함수 표현식에 이름을 줄 수 있다. -> 그 때 변수의 이름과 함수 표현식의 이름이 다를 때는 변수의 이름으로 호출해야 한다.
- 그렇다면 함수 표현식의 이름을 왜 써주냐 -> 디버깅할때 편하라고

### 인스턴스의 생성
- new를 붙여야 한다.
### constructor
- 인스턴스를 생성
- 멤버 변수를 초기화
- 생략할 수 있다. -> 엔진은 있는 것처럼 행동한다.
### 멤버변수
- 반드시 콘스트럭트 내부에서 this로 만들어야한다.
### 호이스팅
- 스코프를 최대한 줄이는 것이 좋다.
### getter / setter
- 굉장히 유용

### 클래스 상속
- super: 부모클래스의 
- static 메서드



8. 모듈(Module)
- <http://poiemaweb.com/es6-module>
- import / export 쪼개서 사용
- 중요 ****
- 모듈 로더 -> 분리되어있는 자바스크립트 모듈을 불러올 수 있는 것.
- babel & webpack
- webpack -> 모듈 번들러 -> 여러가지 자바스크립트 파일을 하나로 묶는 것을 번들이라고 한다. -> 걸프..
- 사람이 많으면 여러가지 파일로 쪼갤 수 밖에 없다. 대규모 프로젝트라면 기능별로 나눠야 한다.

- 모듈의 문법 / 바벨의 사용법 / 웹팩의 사용법


----
여기부터는 어렵다.
----



## 9. 프로미스(Promise)
- <http://poiemaweb.com/es6-promise>
## 10. 이터레이션 프로토콜(iteration protocol)과 for-of 루프
- <http://poiemaweb.com/es6-iteration-for-of>
## 11. 심볼(Symbol)
- <http://poiemaweb.com/es6-symbol>
## 12. 제너레이터(Generator)
- <http://poiemaweb.com/es6-generateor>


## 13. Babel 6와 Webpack 3를 이용한 ES6 환경 구축
- <http://poiemaweb.com/es6-babel>


- 2015년 ECMAscript6
  > es5를 탄탄하게 배운 바탕 위에서 es6를 배워야 한다.
  > 지금 프론트엔드는 춘추전국시대임. 계속해서 많은 라이브러리와 언어가 개발되고있다.
  > 자바스크립트는 프로토타입, 객체, 함수형, 절차 지향적 언어 인데 다른 객체지향 언어들과 차이점이 줄어들고 있다.
  > this의 움직임이 틀림.
  > 클래스를 만들고, new로 인스턴트를 만들고, 인스턴트로 상속을 하고
  > 그동안 es5에서 객체처럼 사용했던 것들 -> new 연산자를 만든다던가, prototype을 이용해서 상속을 시킨다던가
  > 상속을 표현할 수 있다. -> 원래 자바스크립트는 상속을 사용하라고 만들어진 언어가 아님
  > es4가 없는 이유 : 브라우저간의 전쟁 -> 표준을 만들 수가 없었다.

- 얼마나 조리있는 언어를 구사하면서 자기가 배운 기술을 자기 입으로 설명할 수 있는것.
- 개념들을 자기만의 언어로 정의 내려야 한다.

## 객체지향
- 요즘은 다시 함수형이 대세
- 자바는 객체형, 자바스크립트는 함수형인데 자바는 점점 함수형으로 가고, 자바스크립트는 객체형으로 가고있다.
- 
## Typescript
